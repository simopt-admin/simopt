"""Terminal scatter plot."""

from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np

from simopt.experiment import ProblemSolver
from simopt.plot_type import PlotType

from .utils import save_plot, setup_plot


def plot_terminal_scatterplots(
    experiments: list[list[ProblemSolver]],
    all_in_one: float = True,
    plot_title: str | None = None,
    legend_loc: str | None = None,
    ext: str = ".png",
    save_as_pickle: bool = False,
    solver_set_name: str = "SOLVER_SET",
    problem_set_name: str = "PROBLEM_SET",
) -> list[Path]:
    """Plot scatter plots of the mean and standard deviation of terminal progress.

    Either creates one plot per solver or a combined plot for all solvers.

    Args:
        experiments (list[list[ProblemSolver]]): Problem-solver pairs used to produce
            plots.
        all_in_one (bool, optional): Whether to plot all solvers in one figure.
            Defaults to True.
        plot_title (str | None, optional): Title to override the autogenerated one
            (only applies if `all_in_one` is True).
        legend_loc (str | None, optional): Location of the legend (e.g., "best").
            Defaults to None.
        ext (str, optional): File extension to use for output images.
            Defaults to ".png".
        save_as_pickle (bool, optional): Whether to also save the plots as `.pickle`
            files. Defaults to False.
        solver_set_name (str, optional): Name for the solver group used in plot titles.
            Defaults to "SOLVER_SET".
        problem_set_name (str, optional): Name for the problem group used in plot
            titles. Defaults to "PROBLEM_SET".

    Returns:
        list[Path]: A list of file paths to the plots produced.
    """
    if legend_loc is None:
        legend_loc = "best"

    file_list = []
    # Set up plot.
    n_solvers = len(experiments)
    n_problems = len(experiments[0])
    if all_in_one:
        marker_list = ["o", "v", "s", "*", "P", "X", "D", "V", ">", "<"]
        setup_plot(
            plot_type=PlotType.TERMINAL_SCATTER,
            solver_name=solver_set_name,
            problem_name=problem_set_name,
            plot_title=plot_title,
        )
        solver_names = [
            solver_experiments[0].solver.name for solver_experiments in experiments
        ]
        solver_curve_handles = []
        handle = None
        for solver_idx in range(n_solvers):
            for problem_idx in range(n_problems):
                experiment = experiments[solver_idx][problem_idx]
                color_str = "C" + str(solver_idx)
                marker_str = marker_list[
                    solver_idx % len(marker_list)
                ]  # Cycle through list of marker types.
                # Plot mean and standard deviation of terminal progress.
                terminals = [curve.y_vals[-1] for curve in experiment.progress_curves]
                mean_estimator = np.mean(terminals)
                std_dev_estimator = np.std(terminals, ddof=1)
                handle = plt.scatter(
                    x=mean_estimator,
                    y=std_dev_estimator,
                    color=color_str,
                    marker=marker_str,
                )
            solver_curve_handles.append(handle)
        plt.legend(handles=solver_curve_handles, labels=solver_names, loc=legend_loc)
        file_list.append(
            save_plot(
                solver_name=solver_set_name,
                problem_name=problem_set_name,
                plot_type=PlotType.TERMINAL_SCATTER,
                normalize=True,
                plot_title=plot_title,
                ext=ext,
                save_as_pickle=save_as_pickle,
            )
        )
    else:
        for solver_idx in range(n_solvers):
            ref_experiment = experiments[solver_idx][0]
            setup_plot(
                plot_type=PlotType.TERMINAL_SCATTER,
                solver_name=ref_experiment.solver.name,
                problem_name=problem_set_name,
            )
            experiment = None
            for problem_idx in range(n_problems):
                experiment = experiments[solver_idx][problem_idx]
                # Plot mean and standard deviation of terminal progress.
                terminals = [curve.y_vals[-1] for curve in experiment.progress_curves]
                mean_estimator = np.mean(terminals)
                std_dev_estimator = np.std(terminals, ddof=1)
                handle = plt.scatter(
                    x=mean_estimator,
                    y=std_dev_estimator,
                    color="C0",
                    marker="o",
                )
            if experiment is not None:
                file_list.append(
                    save_plot(
                        solver_name=experiment.solver.name,
                        problem_name=problem_set_name,
                        plot_type=PlotType.TERMINAL_SCATTER,
                        normalize=True,
                        ext=ext,
                        save_as_pickle=save_as_pickle,
                    )
                )
    return file_list
